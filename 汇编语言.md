# 汇编语言(3rd)

> 编者：王爽

  * [ ] 本书重点：通过学习关键字指令来深入理解机器工作的基本原理，培养底层编程意识和思想。
  
1. 不讲解每一条指令的功能
   指令仅仅是学习机器基本原理和设计思想的一种实例。而逐条讲解每一条指令的功能，不是本书的职责所在，它应该是一本指令手册该干的事情。
2. 编程的平台是硬件而不是操作系统
3. 着重讲解重要指令和关键概念

> ## 读者定位
> 本书的读者应该具有一下的几个基础：
> - 具有计算机的基本使用经验
ii> - 具有二进制、十六进制的基本知识
> - 具有一门高级语言的基本编程基础

## 第一章 基础知识

机器语言就是**机器指令的集合**。

### 汇编语言的产生

汇编语言的主体: **汇编指令**

作用：由于机器码太过于晦涩难懂，导致很难直接去掌握，而汇编作为一种约定俗成的助记码

### 汇编语言的组成

汇编语言主要由以下的几类指令组成：

1. 汇编指令：机器码的助记符号，有对应的机器码

2. 伪指令：没有对应的机器码，由编译器执行，计算机并不执行

3. 其他符号：如`+,-,*,/`等，由编译器识别，没有对应的机器码

汇编语言的核心是**汇编指令**，它决定了汇编语言的特性。

### 存储器

CPU是计算机的核心部件，它控制着整个的计算机的运作并进行运算。

### 指令和数据

指令和数据在磁盘上是没有任何区别的，都是二进制的数据。

#### 存储单元


存储单元是指的数据在磁盘内的存储格式，一般为二进制

$$
1KB=1024B, 1MB=1024KB, 1GB=1024MB,1T=1024GB
$$

### CPU对于寄存器的读写

CPU要从内存中读取数据，首先要个指定存储单元地址。也就是说要先确定它读取哪个存储单元的数据。

CPU想要进行数据的读写，必须和外部器件进行三类信息的交互：

- 存储单元的地址(地址信息)

- 器件的选择，读或者写的命令(控制信息)

- 读或写的数据(数据信息)

CPU通过*总线*来跟其他芯片进行交互，从逻辑上总线又分为三类：

1. 地址总线

2. 控制总线

3. 数据总线


##### 地址总线

CPU是地址总线来指定存储单元。

地址总线上能传送多少个信息，那么CPU就可以对多少个存储单元进行寻址。

> 一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N，。这样的CPU最多可以寻找$2^N$次方个内存单元

##### 数据总线

CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。

N根数据总线一次可以传送N位二进制数据。

###### 控制总线

CPU对外部器件的控制是通过控制总线进行的。控制总线是一系列不同的控制线的集合。

有多少根控制总线，就意味着CPU提供了外部器件的多少种控制。(**决定了CPU对外部器件的控制能力**)


### 内存地址空间

内存地址空间是指CPU通过地址总线能寻找到的最大的内存单元组成的内存空间。

### 各类存储器芯片

一台PC机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的、不同的器件。

从读写属性上分为两类：**随机存储器(RAM)**、**只读存储器(ROM)**

*随机存储器(RAM)*:可读可写，但必须带电存储

*只读存储器(ROM)*:仅可读，关机后存储内容不会丢失。

存储器从功能上还能分成以下几类:

- 随机存储器：用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM组成，装在主板上的RAM和插在扩展插槽上的RAM

- 装有BIOS的ROM，

- 接口卡上的RAM

### 内存地址空间

上述那些存储器，在物理上是独立的器件，但是在以下两点上相同

- 都和CPU的总线相连

- CPU对它们进行读或者写的时候都通过控制线发出内存读写命令

> 也就是说，CPU在操控它时，把它们都当作内存来对待，把它们总的看作是一个由若干存储单元组成的逻辑存储器。这个逻辑存储器就是**内存地址空间**。

所有的物理存储器被看作是若干个存储单元组成的逻辑存储器。

## 第二章 存储器

 为什么要使用存储器来存储?
 
 一个典型的CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。
 
在CPU中：

- 运算器进行信息处理;

- 寄存器进行信息存储;

- 控制器控制各种器件进行工作;

- 内部总线连接各种器件，在它们之间进行数据的传送;

### 通用寄存器

8086CPU的所有寄存器都是16位的，可以存放两个字节。`AX,BX,CX,DX`这四个寄存器通常用来存放一般性的数据，被称为通用寄存器。

8086CPU的上一代CPU中的寄存器都是8位的，为了保证兼容，使原来的基于上一代的CPU编写的程序稍加修改就可以运行在8086的CPU上。

- AX可以分为AH和AL

- BX可以分为BH和BL

- CX可以分为CH和CL

- DX可以分为DH和DL

在上述的寄存器的分寄存器中，每个都可以独立使用

### 字在寄存器中的存储

出于对兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据。

- 字节(byte):一个字节由8个bit构成，可以存在8位寄存器中。

- 字(word):一个字由两个字节组成,刚好可以分为高位和低位字节。

### 几条汇编指令

|汇编指令|控制CPU完成的操作|用高级语言的语法描述|
|---|---|---|
|`mov ax,18`|将18送入寄存器`AX`|`AX=18`|
|`mov ah,78`|将78送入寄存器`AH`|`AH=78`|
|`add ax,8`|将寄存器AX中的数值加上8|`AX=AX+8`|
|`mov ax,bx`|将寄存器`BX`中的数据送入寄存器`AX`|`AX=BX`|
|`add ax,bx`|将`AX`和`BX`中的数值相加，结果存在`AX`中|`AX=AX+BX`|

### 物理地址

当我们要访问CPU的内存单元的时候，要给出内存单元的对应的地址。所有的内存单元构成的存储空间是一个一维的线性空间。

#### 16位结构的CPU

16位CPU的定义：*概括的讲，16位结构描述了一个CPU具有以下几个方面的特性*

1. **运算器一次最多可以处理16位的数据**

2. **寄存器的最大宽度为16位**

3. **寄存器和运算器之间的通路为16位**

在16位的CPU上一次性能处理的数据的最大位数为16位。

##### 8086CPU给出物理地址的方法
8086CPU一共有20位的地址总线，一次可以传送出20位的数据，具有$2^(20/2)$位的寻址能力。但是由于8086CPU只有16位，导致实际的寻址能力只有64KB，因此在实际上的处理中，8086CPU采用了在内部用两个16位的地址合成的方法来形成一个20位的物理地址。

//此处应该插入8086 CPU有关的逻辑结构图

根据图示，当8086CPU想要读写内存时：

1. CPU中的相关部件提供两个16位的地址，一个称为**段地址**，另一个称为**偏移地址**

2. *段地址*和偏移地址通过内部总线送入一个称为**地址加法器**的部件

3. 地址加法器将两个16位地址合成为一个20位的物理地址

4. 地址加法器通过内部总线将20位物理地址送入输入输出控制电路

5. 输入输出控制电路将20位物理地址送上地址总线

6. 20位物理地址被地址总线传送到存储器

地址加法器采用**物理地址=段地址✖16+偏移地址**的方法用段地址和偏移地址合成物理地址。

#### “段地址✖16+偏移地址=物理地址"的本质原理

这里仅仅讨论的是8086CPU中的段地址和偏移地址的本质含义，而不是为了解决某个具体的问题而在本质含义上引申出来的更高级的逻辑意义。

段地址和偏移地址的偏移的本质意义是：**CPU在访问内存的时候，用一个基础的地址和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址**。

#### 段的概念

段来自于CPU,由于8086CPU用基础地址合成的方式来给出内存的物理地址，使得我们可以使用内存分段的方式来管理内存。


##### CS和IP

这两个是8086CPU中的最关键的两个寄存器。****它们指示了CPU当前要读取的指令的地址**

CS:代码段寄存器

IP:指令指针寄存器

> 此处应该插入流水线图，着重讲解如何进行输出

指令步骤：

1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器。

2. `IP=IP+所读取的指令的长度`，从而指向下一条指令

3. 执行该指令，转到步骤1重复这个过程

#### 修改CS、IP的指令

在CPU中，程序员能够用指令读写的部件只有寄存器。程序员可以通过改变寄存器中的内容来实现对CPU的控制。

*CPU中的指令是通过改变寄存器中的内容实现对CPU的控制。CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS，IP中的内容来实现控制CPU执行目标指令*

### 第三章 寄存器(内存访问)

#### 内存中字的存储

CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。

字单元：**存放一个字型数据（16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高字节，低地址内存单元中存放字型数据的低字节**。

### DS和[address]

CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。*8086CPU中有一个DS寄存器，通常用来寄存要访问数据的段地址*。

例子解析：

```asm
mov bx,1000H
mov ds,bx
mov al,[0]
```
以下的指令的含义：

```asm
mov al,[0]
```

使用以上的指令，可以完成两种传送：

1. 将数据直接送入寄存器;

2. 将一个寄存器中的内容送入另一个寄存器;

> `[...]`表示一个内存单元，`[...]`中的0表示内存单元的偏移地址

通过上述的偏移地址加上ds中的段地址，才能正常寻址。


### 字的传送

`mov`指令在寄存器和内存之间进行字节型数据的传送。因为8086CPU是16位结构，有16跟数据线。

### mov,add,sub指令

`mov`指令可以有以下几种形式：

|指令|例子|
|---|---|
|`mov reg,data`|`mov ax,8`|
|`mov reg,reg`| `mov ax,bx`|
|`mov reg,mmu`|`mov ax,[0]`|
|`mov mmu.reg`|`mov [0],ax`|
|`mov sreg,reg`|`mov ds,ax`|

### 数据段

在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为N(N<=64KB)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。

如何1访问数据段中的数据？-> 将一段内存当作数据段

可以在具体操作的时候，用DS存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。

#### 栈

在这里，我们对栈的研究仅限于这个角度：**栈是一种具有特殊的访问方式的存储空间**。特殊性在于——*最后进入这个空间的数据，最先出去*(先进后出)

### CPU提供的栈机制

现今的CPU中都有栈的设计，8086CPU也不例外。**这意味着，在基于8086CPU编程的时候，可以将一段内存当作栈来使用**

  * [ ]
  
#### 第一个程序

在前面的章节中，一般都是在`Debug`命令模式中写的指令。现在本章需要将这些指令通过连接和编译形成可执行的文件。

##### 一个源程序从写出到执行的过程

从汇编到可执行程序的过程：

1. 编写汇编源程序

2. 对源程序进行链接和编译

3. 执行可执行文件中的程序 

通过上述两部可以将汇编源代码转换成可执行文件并在对应的平台上运行该可执行文件。

可执行文件包含两部分内容：

- 程序代码(从汇编指令翻译过来的机器码)和数据(从源程序中定义的静态类型数据)

- 相关的描述信息(这个类型的内容一般占比很少，只是告诉机器该程序的详细信息)

##### 源程序

下面是简单的汇编语言源程序

```asm
assume cs:codesg
codesg segment
    mov ax,0123H
    mov bx,0456H
    add ax,bx
    add bx,ax
    
    mov ax,4c00H
    int 21H
codesg ends
end
```

1. 伪指令

在汇编程序中，包含两种指令：

- 汇编指令

- 伪指令


1. 段声明
```asm
segm

ends
```
上述代码片段用于定义一个段，`segment`说明一个段开始，`ends`说明一个段结束。

2. end

`end`是一个汇编程序的结束标记，编译器在汇编程序的过程中，如果碰到了伪指令`end`，那么编译器就会结束对源程序的编译。

3. assume

这条伪指令的含义是“假设”，它假设某一段寄存器和程序中的某一个用`segment...ends`定义的段相关联。在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。

在汇编程序中，除了汇编指令和伪指令之外，还有一些标号，一个标号指代了一个地址。

在目前阶段，需要在每个段内存指令结束后加上：

```asm
mov ax,4c00H
int 21H

```

上述代码可以将段指令结束。

程序在DOS中运行的结果如下所示：

Edit->.asm file->compile(masm)->.obj file->link->.exe file->load(command)-> the program in cache->run(CPU)

###### 如何跟踪正在执行的程序？

对于一个程序来说，难免会发生错误，因此有的时候需要对程序的整个运行过程做一个详细的跟踪。即使用`Debug`模式来对堆栈进行分析，

> 当然，目前有更好的图形化工具代替，没必要再死纠结在DOS系统上那功能少得可怜的Debug模式了

在DOS系统中.EXE文件中的程序加载过程：

1. 在内存中找到一段起始地址为`SA:0000`（即起始地址的偏移地址为0)的容量足够的空闲内存区。

2. 在这段内存区的前256个字节中，创建一个成为**程序段前缀(PSP)**的数据区，DOS要利用`PSP`来和被加载程序进行通信

3. 从`PSP`的后面开始，将程序装入，程序的地址被设置为`SA+10H:0`

> 空闲内存区: `SA:0`
> PSP区:`SA:0`
> 程序区:`SA+10H:0`

4. 将该内存区的段地址存入`ds`中，初始化其他相关寄存器后，设置`CS:IP`指向程序的入口


#### [BX]和loop指令

假设以下的问题：计算内存单元`ffff:0~ffff:b`中的所有数据的和，并将其存储到`ds`中

```asm

assume codesg

codesg segment
    mov ax,0ffffh
    mov ds,ax
    mov bx,0
    
    mov dx,0
    mov cx,12
    
    s: mov al,[bx]
    mov ah,0
    add ds,ax
    inc bx
    loop s
    mov ax,4c00h
    int 21h
codesg ends
end
```

#### 段前缀

出现正在访问内存单元的指令中，用于显式地指明内存单元的段地址的寄存器说明，称为段前缀，例如`ds:,cs:`等

##### 一段安全的空间

对于随时向内存中写入汇编代码是一种十分危险的行为，因为不知道准备使用的内存空间是否存有数据，或者说是否为空白地址。

因此我们应该使用操作系统提供给我们分配的空间来进行操作，尽量不去碰非分配区域的内存地址。

> 如何找到一段合适的内存空间地址？
> 一般来说，DOS和其他的合法程序都不会使用`0:200~0:2ff`的256字节的空间，这段内存地址是比较安全的。若担心中间仍然存放有数据，那么可以使用Debug模式进行查看是否全为零。

#### 段前缀的使用

考虑一个问题：将内存`ffff:0~ffff:b`单元中的数据复制到`0:200~0:20b`单元中的数据复制到

分析

1. `0:200~0:20b`单元等同于`0020:0~0020:b`单元，它们描述的是同一段内存空间。

2. 复制的过程应用循环实现

3. 在循环过程中，源始单元`ffff:X`和目标单元`0020:X`的偏移地址`X`是变量。

4. 将`0:200~0:20b`用`0020:0~0020:b`描述，就是为了使目标单元的便宜地址和源始单元的偏移地址从同一数值0开始


```asm
assume cs:code

code segment
    mov bx,0
    mov cx,12
s:  mov ax,0ffffh
    mov ds,ax
    mov dl,[bx]
    
    mov ax,0020h
    mov ds,ax
    mov [bx],dl
    
    inc bx
    loop sub
    
    mov ax,4c00h
    int 21h
code ends
end
```

上述程序的效率并不是很高，寄存器的利用效率很低

改进的程序如下所示：

```asm
assume cs:code
    mov ax,0ffffh
    mov ds,ax
    
    mov ax,0020h
    mov es,ax
    
    mov bx,0
    
   mov cx,12
   
   s: mov dl,[bx]
   mov es:[bx],dl
   inc bx
   loop sub
   
   mov ax,4c00h
   int 21h
code ends
end
```

### 包含多个段的程序

对于前面的程序，基本都是一个代码段。但是实际情况是，一个程序一般情况下会使用多个段空间来存放数据。

程序获取所需的空间的办法有两种：

- 加载程序的时候为其进行分配

- 在程序正在运行的时候向系统申请代码的存储空间

我们接下来要深入的讨论多个段的问题：

1. 在一个段中存放数据、代码、堆栈

2. 将数据、代码、段放到不同的段中

#### 在代码段中使用数据


考虑以下的问题：

将以下的数据的和存储到`ax`寄存器中

`0123h`，`0456h`,`0789h`,`0abch`,`0defh`,`0fedh`,`0cbah`,`0987h`

```asm

assume cs:code

code segment 
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
    
    mov bx,0
    mov ax,0
    
    mov cx,8
    s:add ax,cs:[bx]
    
```

在上述代码中`dw`表示定义字节型数据，定义了8个字节型数据，它们所占用的地方大小为16字节

> end的作用：end除了通知编译器程序结束之外，还可以通知编译器该程序的入口在哪里

```asm
assume cs:code
    code segment
        :
        :
        ;数据
        :
        :
    start:
        :
        :
        ;代码
        :
        :
code ends
end start
```

#### 在代码段中使用栈

利用栈，将程序中定义的数据逆序存放
```asm
assume cs:codesg

codesg segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
    ?
codesg ends
end

```

问题是，我们首先要有一段可以当作栈的内存空间。系统可以帮我们分配好栈内存，我们仅需向系统进行申请。

```asm

assume cs:codesg
codesg segment
    dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
    dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        ;用dw定义16个字型数据，在程序加载后，将取得16个字的内存空间，存放这16个数据。在后面的程序中将这段空间当作栈来使用
start: mov ax,cs
       mov ss,ax
       mov sp,30h   ;将设置栈顶ss:sp指向cs:30
       
       mov bx,0
       mov cx,8
s:     push cs:[bx]
       add bx,2
       loop s
       
       mov bx,0
       mov cx,8
       
s0:    pop cs:[bx]
       add bx,2
       loop s0
       
       mov ax,4c00h
       int 21h
    codesg ends
    end start
```

通过`dw`定义申请了一段16字节的内存空间，再将`ss:sp`指向该空间，随后进行堆栈操作。

#### 将数据、代码、栈放入不同的内存段

如果将数据、代码都放入一个段里面，会有以下两个问题：

1. 把它们放到一个段中虽然程序可以正常运行，但是程序看起来十分的混乱

2. 前面的程序中处理的数据量级太小，所用到的栈空间也很小，加上代码量也不大，所以放到一个段里面没有任何的问题。如果数据、栈和代码所需要的空间超过了64KB，就不能放到一个段中了。

以下是使用多个段的程序

```asm
assume cs:code,ds:data,ss:stack
    data segment
        dw 0123h,0456h,0789h,0abch,0defh,0fedh,0cbah,0987h
    data ends
    ;data 数据段
    stack segment
        dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    stack ends
    code segment
    start: mov ax,stack
    mov ss,ax
    mov sp,20h ;设置栈顶ss:sp指向stack:20
    mov ax,data
    mov ds,ax ;ds指向data段
    
    mov bx,0 ;ds:bx 指向data段中的第一个单元
    
    mov cx,8 
    s: push [bx]
        add bx,2
        loop s  ;以上将data段中的0~15单元中的8个字型数据依次入栈
        
        mov bx,0
        
        mov cx,8
    s0: pop [bx]
        add bx,2
        loop s0
        
        mov aax,4c00h
        int 21h
code ends
end start
```

以下是对上述程序说明：

1. 定义多个段的方法

定义一个段的方法和前面所讲的定义代码段的方法没有任何区别，只是对于不同的段，要有不同的段名

2. 段地址的引用

如何访问多个段中的数据呢？需要通过地址，而地址是分为两个部分的，即段地址和偏移地址

如何指明访问的段地址？

```asm
mov ax,data
mov ds,ax
mov mov bx,ds:[6]

```

> 为什么不能直接将data写入--因为8086CPU不允许将一个数值直接送入段寄存器中

3. 对于段的安排，实际上并没有任何的意义，你喜欢什么样安排代码段的名称就怎么称呼


程序可以改写成以下的形式：

```asm
assume cs:b,ds:a,ss:c
    a segment
        dw 0123h,0456h,0789h,0abch,0edfh,0fedh,0987h
    a ends
    
    c segment
        dw 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    c ends
   
   b segment
d: mov ax,c
   mov ss,ax
   mov sp,20h
   
   mov ax,a
   mov ds,ax
   
   mov bx,0
   mov cx,8
   
   s:push [bx]
    add bx,2
    loop s
    
    mov bx,
   s:push [bx]
    add bx,2
    loop s
    
    mov bx,0
    mov cx,8
    s0: pop [bx]
    add bx,2
    loop s0
    
    mov ax,4c00h
    int 21h
    
    b ends
    end b
```

#### 更灵活的定位内存地址的方法

##### and 和 or 指令

下面介绍两个指令的内容

1. `and`指令:逻辑和指令，按位进行与运算

```asm
mov al,01100011B
and al,00111011B
```
执行结果如下：
```asm
al=00100011B
```
该指令可以将对象的相应位设置为0,而其他位不变

2. `or`指令:逻辑和指令，按位进行或运算

```asm
mov al,01100011B
or al,00111011B
```
执行结果如下：
```asm
al=01111011B
```

通过该指令可以将对象的对应位设置为1,其他位不变

#### [bx+idata]

在前面，我们使用`[bx]`来指明一个内存单元，我们还可以用一种更灵活的方式来指明内存单元：**`[bx+idata]`表示一个内存单元，它的偏移地址为`(bx)+idata`**


##### 用[bx+idata]的方式进行内存处理

有了`[bx+idata]`这种表示内存单元的方式，我们就可以使用更高级的结构来处理数据

```asm
assume cs:codesg,ds:datasg
    datasg segment
        db 'BaSiC'
        db 'MinIX'
    datasg ends
    
    codesg segment
        start:
            mov ax,datasg
            mov ds,ax
            mov bx,0
            
            mov cx,5
            
            s: mov al,[bx]
                and al,11011111b
                mov [bx],al
                inc bx
            loop s
            
            mov bx,5
            mov cx,5
            
            s0: mov al,[bx]
                or al,00100000b
                mov [bx],al
                inc bx
                loop s0
            
    codesg ends
    
    end start
```
上述代码是一个比较复杂的形式，没有使用`[bx+idata]`的方式进行复杂度优化

改进程序如下所示：
```asm
mov ax,datasg
mov ds,ax
mov bx,0
mov cx,5

s:  mov al,[bx]
    and al,11011111b
    mov [bx],al
    mov al,[5+bx]
    or al,00100000b
    mov [5+bx],al
    inc bx
    loop s
```

当然，你也可以使用C语言混合汇编语言来写

##### SI和DI

`SI`和`DI`都是8086中和`bx`功能相近的寄存器，`si`和`di`不能够分成两个8位寄存器来使用。

实际上和bx都是等效的，

###### [bx+si]和[bx+di]

在前面，我们使用`[bx]`或者`[bx+idata]`来指明一个内存单元，我们还可以用更会灵活的方式：**`[bx+si]`和`[bx+di]`**

`[bx+di]`表示一个内存单元，其偏移地址为`(bx)+(si)`

数学描述:
```asm
(ax)=((ds)*16+(bx)+(si))
```

##### [bx+si+idata]和[bx+di+idata]

同理，上述的数学表示为

```asm
(ax)=((ds)*16+(bx)+(si)+idata)
```

#### 不同寻址方式的灵活应用

比较几种常用的寻址方式，可以得出以下的结论：

1. `[idata]`用一个常量表示一个地址，可以用于直接定位一个内存单元

2. `[bx]`用一个变量来表示一个地址，可以用于间接定位一个内存单元

3. `[bx+si]`用两个变量表示地址

4. `[bx+si+idata]`用两个变量和一个常量表示地址

我们使用内存来暂存数据，这一点是确定的，但是值得推敲的是，应该用什么样的数据结构来保存该数据，才能使得程序更加地清晰。
**一般来说，在需要暂存数据的时候，我们都应当使用栈结构来存储**

### 数据处理的两个基本问题

1. 处理的数据在什么地方？(需要内存地址)

2. 要处理的数据有多长?(需要数据类型以及寄存器类型)

定义描述性符号

- 寄存器符号`reg`

- 段寄存器符号`sreg`

#### bx,si,di,sp

前面已经介绍了前三个寄存器如何使用，下面是总结：

1. 在8086CPU中，只有这四个寄存器可以用在`[...]`中来进行内存单元寻址

2. 在`[...]`中，这四个寄存器都可以但个出现，或者能以4种组合出现：
   - `bx`+`si`
   
   - `bx`+`di`
   
   - `si`+`bp`
   
   - `bp`+`di`
   
3. **只要在`[...]`中使用寄存器`bp`，而指令没有显性的给出段地址，那么段地址默认就在`ss`中**

