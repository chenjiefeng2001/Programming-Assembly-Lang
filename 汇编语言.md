# 汇编语言(3rd)

> 编者：王爽

  * [ ] 本书重点：通过学习关键字指令来深入理解机器工作的基本原理，培养底层编程意识和思想。
  
1. 不讲解每一条指令的功能
   指令仅仅是学习机器基本原理和设计思想的一种实例。而逐条讲解每一条指令的功能，不是本书的职责所在，它应该是一本指令手册该干的事情。
2. 编程的平台是硬件而不是操作系统
3. 着重讲解重要指令和关键概念

> ## 读者定位
> 本书的读者应该具有一下的几个基础：
> - 具有计算机的基本使用经验
ii> - 具有二进制、十六进制的基本知识
> - 具有一门高级语言的基本编程基础

## 第一章 基础知识

机器语言就是**机器指令的集合**。

### 汇编语言的产生

汇编语言的主体: **汇编指令**

作用：由于机器码太过于晦涩难懂，导致很难直接去掌握，而汇编作为一种约定俗成的助记码

### 汇编语言的组成

汇编语言主要由以下的几类指令组成：

1. 汇编指令：机器码的助记符号，有对应的机器码

2. 伪指令：没有对应的机器码，由编译器执行，计算机并不执行

3. 其他符号：如`+,-,*,/`等，由编译器识别，没有对应的机器码

汇编语言的核心是**汇编指令**，它决定了汇编语言的特性。

### 存储器

CPU是计算机的核心部件，它控制着整个的计算机的运作并进行运算。

### 指令和数据

指令和数据在磁盘上是没有任何区别的，都是二进制的数据。

#### 存储单元


存储单元是指的数据在磁盘内的存储格式，一般为二进制

$$
1KB=1024B, 1MB=1024KB, 1GB=1024MB,1T=1024GB
$$

### CPU对于寄存器的读写

CPU要从内存中读取数据，首先要个指定存储单元地址。也就是说要先确定它读取哪个存储单元的数据。

CPU想要进行数据的读写，必须和外部器件进行三类信息的交互：

- 存储单元的地址(地址信息)

- 器件的选择，读或者写的命令(控制信息)

- 读或写的数据(数据信息)

CPU通过*总线*来跟其他芯片进行交互，从逻辑上总线又分为三类：

1. 地址总线

2. 控制总线

3. 数据总线


##### 地址总线

CPU是地址总线来指定存储单元。

地址总线上能传送多少个信息，那么CPU就可以对多少个存储单元进行寻址。

> 一个CPU有N根地址总线，则可以说这个CPU的地址总线的宽度为N，。这样的CPU最多可以寻找$2^N$次方个内存单元

##### 数据总线

CPU与内存或其他器件之间的数据传送是通过数据总线来进行的。数据总线的宽度决定了CPU和外界的数据传送速度。

N根数据总线一次可以传送N位二进制数据。

###### 控制总线

CPU对外部器件的控制是通过控制总线进行的。控制总线是一系列不同的控制线的集合。

有多少根控制总线，就意味着CPU提供了外部器件的多少种控制。(**决定了CPU对外部器件的控制能力**)


### 内存地址空间

内存地址空间是指CPU通过地址总线能寻找到的最大的内存单元组成的内存空间。

### 各类存储器芯片

一台PC机中，装有多个存储器芯片，这些存储器芯片从物理连接上看是独立的、不同的器件。

从读写属性上分为两类：**随机存储器(RAM)**、**只读存储器(ROM)**

*随机存储器(RAM)*:可读可写，但必须带电存储

*只读存储器(ROM)*:仅可读，关机后存储内容不会丢失。

存储器从功能上还能分成以下几类:

- 随机存储器：用于存放供CPU使用的绝大部分程序和数据，主随机存储器一般由两个位置上的RAM组成，装在主板上的RAM和插在扩展插槽上的RAM

- 装有BIOS的ROM，

- 接口卡上的RAM

### 内存地址空间

上述那些存储器，在物理上是独立的器件，但是在以下两点上相同

- 都和CPU的总线相连

- CPU对它们进行读或者写的时候都通过控制线发出内存读写命令

> 也就是说，CPU在操控它时，把它们都当作内存来对待，把它们总的看作是一个由若干存储单元组成的逻辑存储器。这个逻辑存储器就是**内存地址空间**。

所有的物理存储器被看作是若干个存储单元组成的逻辑存储器。

## 第二章 存储器

 为什么要使用存储器来存储?
 
 一个典型的CPU由运算器、控制器、寄存器等器件构成，这些器件靠内部总线相连。
 
在CPU中：

- 运算器进行信息处理;

- 寄存器进行信息存储;

- 控制器控制各种器件进行工作;

- 内部总线连接各种器件，在它们之间进行数据的传送;

### 通用寄存器

8086CPU的所有寄存器都是16位的，可以存放两个字节。`AX,BX,CX,DX`这四个寄存器通常用来存放一般性的数据，被称为通用寄存器。

8086CPU的上一代CPU中的寄存器都是8位的，为了保证兼容，使原来的基于上一代的CPU编写的程序稍加修改就可以运行在8086的CPU上。

- AX可以分为AH和AL

- BX可以分为BH和BL

- CX可以分为CH和CL

- DX可以分为DH和DL

在上述的寄存器的分寄存器中，每个都可以独立使用

### 字在寄存器中的存储

出于对兼容性的考虑，8086CPU可以一次性处理以下两种尺寸的数据。

- 字节(byte):一个字节由8个bit构成，可以存在8位寄存器中。

- 字(word):一个字由两个字节组成,刚好可以分为高位和低位字节。

### 几条汇编指令

|汇编指令|控制CPU完成的操作|用高级语言的语法描述|
|---|---|---|
|`mov ax,18`|将18送入寄存器`AX`|`AX=18`|
|`mov ah,78`|将78送入寄存器`AH`|`AH=78`|
|`add ax,8`|将寄存器AX中的数值加上8|`AX=AX+8`|
|`mov ax,bx`|将寄存器`BX`中的数据送入寄存器`AX`|`AX=BX`|
|`add ax,bx`|将`AX`和`BX`中的数值相加，结果存在`AX`中|`AX=AX+BX`|

### 物理地址

当我们要访问CPU的内存单元的时候，要给出内存单元的对应的地址。所有的内存单元构成的存储空间是一个一维的线性空间。

#### 16位结构的CPU

16位CPU的定义：*概括的讲，16位结构描述了一个CPU具有以下几个方面的特性*

1. **运算器一次最多可以处理16位的数据**

2. **寄存器的最大宽度为16位**

3. **寄存器和运算器之间的通路为16位**

在16位的CPU上一次性能处理的数据的最大位数为16位。

##### 8086CPU给出物理地址的方法
8086CPU一共有20位的地址总线，一次可以传送出20位的数据，具有$2^(20/2)$位的寻址能力。但是由于8086CPU只有16位，导致实际的寻址能力只有64KB，因此在实际上的处理中，8086CPU采用了在内部用两个16位的地址合成的方法来形成一个20位的物理地址。

//此处应该插入8086 CPU有关的逻辑结构图

根据图示，当8086CPU想要读写内存时：

1. CPU中的相关部件提供两个16位的地址，一个称为**段地址**，另一个称为**偏移地址**

2. *段地址*和偏移地址通过内部总线送入一个称为**地址加法器**的部件

3. 地址加法器将两个16位地址合成为一个20位的物理地址

4. 地址加法器通过内部总线将20位物理地址送入输入输出控制电路

5. 输入输出控制电路将20位物理地址送上地址总线

6. 20位物理地址被地址总线传送到存储器

地址加法器采用**物理地址=段地址✖16+偏移地址**的方法用段地址和偏移地址合成物理地址。

#### “段地址✖16+偏移地址=物理地址"的本质原理

这里仅仅讨论的是8086CPU中的段地址和偏移地址的本质含义，而不是为了解决某个具体的问题而在本质含义上引申出来的更高级的逻辑意义。

段地址和偏移地址的偏移的本质意义是：**CPU在访问内存的时候，用一个基础的地址和一个相对于基础地址的偏移地址相加，给出内存单元的物理地址**。

#### 段的概念

段来自于CPU,由于8086CPU用基础地址合成的方式来给出内存的物理地址，使得我们可以使用内存分段的方式来管理内存。


##### CS和IP

这两个是8086CPU中的最关键的两个寄存器。****它们指示了CPU当前要读取的指令的地址**

CS:代码段寄存器

IP:指令指针寄存器

> 此处应该插入流水线图，着重讲解如何进行输出

指令步骤：

1. 从CS:IP指向的内存单元读取指令，读取的指令进入指令缓冲器。

2. `IP=IP+所读取的指令的长度`，从而指向下一条指令

3. 执行该指令，转到步骤1重复这个过程

#### 修改CS、IP的指令

在CPU中，程序员能够用指令读写的部件只有寄存器。程序员可以通过改变寄存器中的内容来实现对CPU的控制。

*CPU中的指令是通过改变寄存器中的内容实现对CPU的控制。CPU从何处执行指令是由CS、IP中的内容决定的，程序员可以通过改变CS，IP中的内容来实现控制CPU执行目标指令*

### 第三章 寄存器(内存访问)

#### 内存中字的存储

CPU中，用16位寄存器来存储一个字。高8位存放高位字节，低8位存放低位字节。

字单元：**存放一个字型数据（16位)的内存单元，由两个地址连续的内存单元组成。高地址内存单元中存放字型数据的高字节，低地址内存单元中存放字型数据的低字节**。

### DS和[address]

CPU要读写一个内存单元的时候，必须先给出这个内存单元的地址，在8086PC中，内存地址由段地址和偏移地址组成。*8086CPU中有一个DS寄存器，通常用来寄存要访问数据的段地址*。

例子解析：

```asm
mov bx,1000H
mov ds,bx
mov al,[0]
```
以下的指令的含义：

```asm
mov al,[0]
```

使用以上的指令，可以完成两种传送：

1. 将数据直接送入寄存器;

2. 将一个寄存器中的内容送入另一个寄存器;

> `[...]`表示一个内存单元，`[...]`中的0表示内存单元的偏移地址

通过上述的偏移地址加上ds中的段地址，才能正常寻址。


### 字的传送

`mov`指令在寄存器和内存之间进行字节型数据的传送。因为8086CPU是16位结构，有16跟数据线。

### mov,add,sub指令

`mov`指令可以有以下几种形式：

|指令|例子|
|---|---|
|`mov reg,data`|`mov ax,8`|
|`mov reg,reg`| `mov ax,bx`|
|`mov reg,mmu`|`mov ax,[0]`|
|`mov mmu.reg`|`mov [0],ax`|
|`mov sreg,reg`|`mov ds,ax`|

### 数据段

在编程时，可以根据需要，将一组内存单元定义为一个段。我们可以将一组长度为N(N<=64KB)、地址连续、起始地址为16的倍数的内存单元当作专门存储数据的内存空间，从而定义了一个数据段。

如何1访问数据段中的数据？-> 将一段内存当作数据段

可以在具体操作的时候，用DS存放数据段的段地址，再根据需要，用相关指令访问数据段中的具体单元。

#### 栈

在这里，我们对栈的研究仅限于这个角度：**栈是一种具有特殊的访问方式的存储空间**。特殊性在于——*最后进入这个空间的数据，最先出去*(先进后出)

### CPU提供的栈机制

现今的CPU中都有栈的设计，8086CPU也不例外。**这意味着，在基于8086CPU编程的时候，可以将一段内存当作栈来使用**

  * [ ]
  
#### 第一个程序

在前面的章节中，一般都是在`Debug`命令模式中写的指令。现在本章需要将这些指令通过连接和编译形成可执行的文件。

##### 一个源程序从写出到执行的过程

从汇编到可执行程序的过程：

1. 编写汇编源程序

2. 对源程序进行链接和编译

3. 执行可执行文件中的程序 

通过上述两部可以将汇编源代码转换成可执行文件并在对应的平台上运行该可执行文件。

可执行文件包含两部分内容：

- 程序代码(从汇编指令翻译过来的机器码)和数据(从源程序中定义的静态类型数据)

- 相关的描述信息(这个类型的内容一般占比很少，只是告诉机器该程序的详细信息)

##### 源程序

下面是简单的汇编语言源程序

```asm
assume cs:codesg
codesg segment
    mov ax,0123H
    mov bx,0456H
    add ax,bx
    add bx,ax
    
    mov ax,4c00H
    int 21H
codesg ends
end
```

1. 伪指令

在汇编程序中，包含两种指令：

- 汇编指令

- 伪指令


1. 段声明
```asm
segm

ends
```
上述代码片段用于定义一个段，`segment`说明一个段开始，`ends`说明一个段结束。

2. end

`end`是一个汇编程序的结束标记，编译器在汇编程序的过程中，如果碰到了伪指令`end`，那么编译器就会结束对源程序的编译。

3. assume

这条伪指令的含义是“假设”，它假设某一段寄存器和程序中的某一个用`segment...ends`定义的段相关联。在需要的情况下，编译程序可以将段寄存器和某一个具体的段相联系。

在汇编程序中，除了汇编指令和伪指令之外，还有一些标号，一个标号指代了一个地址。

在目前阶段，需要在每个段内存指令结束后加上：

```asm
mov ax,4c00H
int 21H

```

上述代码可以将段指令结束。

程序在DOS中运行的结果如下所示：

Edit->.asm file->compile(masm)->.obj file->link->.exe file->load(command)-> the program in cache->run(CPU)

###### 如何跟踪正在执行的程序？

对于一个程序来说，难免会发生错误，因此有的时候需要对程序的整个运行过程做一个详细的跟踪。即使用`Debug`模式来对堆栈进行分析，

> 当然，目前有更好的图形化工具代替，没必要再死纠结在DOS系统上那功能少得可怜的Debug模式了

在DOS系统中.EXE文件中的程序加载过程：

1. 在内存中找到一段起始地址为`SA:0000`（即起始地址的偏移地址为0)的容量足够的空闲内存区。

2. 在这段内存区的前256个字节中，创建一个成为**程序段前缀(PSP)**的数据区，DOS要利用`PSP`来和被加载程序进行通信

3. 从`PSP`的后面开始，将程序装入，程序的地址被设置为`SA+10H:0`

> 空闲内存区: `SA:0`
> PSP区:`SA:0`
> 程序区:`SA+10H:0`

4. 将该内存区的段地址存入`ds`中，初始化其他相关寄存器后，设置`CS:IP`指向程序的入口


#### [BX]和loop指令

